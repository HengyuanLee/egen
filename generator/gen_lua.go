package generator

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/user"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/tealeg/xlsx"
)

var (
	genlua = newGenlua()
)

func Lua() *Genlua {
	return genlua
}

type Genlua struct {
	genPath string
}

func newGenlua() *Genlua {
	g := &Genlua{}
	return g
}
func (g *Genlua) Gen(outPath string) {
	g.genPath = outPath + "/"
	for _, f := range Xlsxfiles {
		fn := filepath.Base(f)
		if !strings.HasPrefix(fn, "~$") && strings.HasSuffix(fn, ".xlsx") {
			g.genLocal(f)
		} else {
			Warn("lua: 排除非xlsx文件 ： " + f)
		}
	}
}
func (g *Genlua) createLuaFile(fname string, buf *bytes.Buffer) {

	outfile := g.genPath + fname + ".lua"
	Info("lua: 正在生成文件 ：" + outfile)
	Info("------------------------------------------------------------------------")
	_, ferr := os.Stat(outfile)
	if ferr == nil {
		os.Remove(outfile)
	}
	os.MkdirAll(filepath.Dir(outfile), 0755)
	ioutil.WriteFile(outfile, buf.Bytes(), 0666)
	luaf := path.Base(outfile)
	luaf = strings.TrimSuffix(luaf, ".lua")
}

func (g *Genlua) genLocal(file string) {

	//Info("------------------------------------------------------------------------")
	Info("lua: 正在读取Excel文件  ： " + file)

	filename := filepath.Base(file)
	filename = strings.TrimSuffix(filename, ".xlsx")

	exlf, ok := getFile(filename)
	if ok {
		genFile := false
		var buf bytes.Buffer
		u, err := user.Current()
		if err == nil {
			buf.WriteString("--Generated by egen, version=" + Version + ". By " + u.Username + ", " + time.Now().Format("2006-01-02 15:04:05") + "\n")
			buf.WriteString(PackageName + " = " + PackageName + " or {}")
			buf.WriteString("\n")
		} else {
			Warn("lua: 生成文件头信息出错")
		}
		for _, sheet := range exlf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && getSheetType(sheet) == "enum" {
				g.parseEnum(sheet, &buf)
				genFile = true
			}
		}

		for i, sheet := range exlf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && getSheetType(sheet) == "object" {
				if i == 0 {
					buf.WriteString("\n")
					buf.WriteString(PackageName + "." + filename + " =")
				}else{
					buf.WriteString(",")
				}
				bs := g.processSheet(filename, sheet.Name)
				buf.WriteString(bs.String())
				genFile = true
			}
		}
		if genFile {
			g.createLuaFile(filename, &buf)
		} else {
			Warn("lua ： not gen")
		}
	}

}

func (g *Genlua) parseEnum(sheet *xlsx.Sheet, buf *bytes.Buffer) {
	if len(sheet.Rows) < 2 {
		Error("lua: 枚举表表头小于2行 : " + sheet.Name)
		return
	}
	nameList := make(map[string]bool, 0)
	valueList := make(map[string]bool, 0)

	buf.WriteString(PackageName + "." + sheet.Name + " = {\n")
	for index, row := range sheet.Rows {
		if index > 1 {
			buf.WriteString("\t")
			fieldName, value, alias, anno, _ := getEnumValue(row)
			if fieldName == "" || value == "" {
				Error("lua: 错误的枚举配置，字段或值配置为空：" + sheet.Name + "/" + fieldName)
				return
			}
			_, ok := valueList[value]
			if ok {
				Error("lua: 重复的枚举值：" + sheet.Name + ":" + value)
				return
			}
			_, ok = nameList[fieldName]
			if ok {
				Error("lua: 重复的枚举字段名：" + sheet.Name + ":" + fieldName)
				return
			}
			valueList[value] = true
			nameList[fieldName] = true
			buf.WriteString(fieldName)
			buf.WriteString(" = ")
			buf.WriteString(value)
			if index < len(sheet.Rows)-1 {
				buf.WriteString(",")
			}
			if alias != "" || anno != "" {
				buf.WriteString("  --")
				buf.WriteString(alias + "  " + anno)
			}
			buf.WriteString("\n")
		}
	}
	buf.WriteString("}\n")
}
func (g *Genlua) processSheet(filename string, sheetName string) *bytes.Buffer {
	Info("lua: 正在读取子表 sheet : " + sheetName + ".xlsx")
	buf := bytes.NewBufferString("")
	buf.WriteString("\n")
	sheet, ok := getFileSheet(filename, sheetName)
	level := 0
	if ok {
		buf.WriteString(getTabs(level) + "{\n")
		if len(sheet.Rows) < 4 {
			Fatal("lua: 表头小于4行" + sheet.Name)
			return buf
		}
		g.processSheetLoop(buf, filename, sheetName, level)
		buf.WriteString("\n" + getTabs(level) + "}")
	}

	return buf
}

func (g *Genlua) processSheetLoop(buf *bytes.Buffer, filename string, sheetName string, level int) {
	sheet, ok := getFileSheet(filename, sheetName)
	if !ok {
		return
	}
	fieldCells := sheet.Rows[2].Cells
	typeCells := sheet.Rows[3].Cells
	fnameid := fieldCells[0].String()
	if strings.TrimPrefix(fnameid, "!") != "id" {
		Error("lua: 错误！要求表格第一列字段必须为 id ,但为 ： " + fnameid)
		return
	}

	level++
	isFirstSheetWirte := true
	//id命中的行数，
	ownerRows := make([]*xlsx.Row, 0)
	for index, row := range sheet.Rows {
		if index >= 4 && len(row.Cells) > 0 {
			mainId := row.Cells[0].String()
			//idName := fieldCells[0].String()
			//如果没有填写id则忽略
			if mainId == "" {
				continue
			}
			ownerRows = append(ownerRows, row)
		}
	}

	for _, row := range ownerRows {
		if isFirstSheetWirte == false {
			buf.WriteString(",\n")
			buf.WriteString(getTabs(level))
		}
		if isFirstSheetWirte {
			buf.WriteString(getTabs(level))
		}
		isFirstSheetWirte = false

		curid := row.Cells[0].String()
		tname := typeCells[0].String()
		if isBaseType(tname) {
			buf.WriteString("[" + curid + "]" + "=")
		} else if tname == "string" {
			buf.WriteString("[\"" + curid + "\"]" + "=")
		} else {
			Error("lua: 每行数据头的字段 id 数据类型只能为基本类型或string")
			continue
		}
		buf.WriteString("{")

		//记录map和list写出的cell，后面不再写出
		writedCellMap := make(map[int]bool, 0)
		//排除属性名为空的字段
		for index, cell := range row.Cells {

			writed, ok := writedCellMap[index]
			if ok && writed {
				continue
			}

			//排除属性名为空的字段
			tname := strings.TrimSpace(typeCells[index].String())
			fname := strings.TrimSpace(fieldCells[index].String())
			value := strings.TrimSpace(cell.String())
			writeTypeStr := typeCells[index].String()
			if fname == "" {
				continue
			}
			if strings.HasPrefix(fname, "!") {
				continue
			}

			isAlias := (getCmdValue(sheet, index, "alias") == "true")
			listSplit := getCmdValue(sheet, index, "split")
			if listSplit == "" {
				listSplit = ","
			}

			buf.WriteString("\n")

			if isAlias {
				if isAlias {
					value = getFileAliasValue(filename, value)
				}
			}

			isMap := isMapField(tname)
			if isMap { //字典kv对
				_, err := strconv.Atoi(fname)
				if err == nil {
					fname = "[" + fname + "]"
				}
			}
			buf.WriteString(getTabs(level + 1))

			//对象是否数组类型
			isList := isListField(tname)
			if isList {
				tname = strings.TrimPrefix(tname, "<")
				tname = strings.TrimSuffix(tname, ">")
			}
			if isBaseType(tname) {
				buf.WriteString(fname + " = ")
				if isList {
					value = ""
					_valList := strings.Split(cell.String(), listSplit)
					newv := ""
					for _, v := range _valList {
						if v == "" {
							continue
						}
						if isAlias {
							newv += getFileAliasValue(filename, v)
						} else {
							newv += v
						}
						newv += ","
					}
					newv = strings.TrimSuffix(newv, ",")
					value += newv
				}
			} else if tname == "string" {
				buf.WriteString(fname + " = ")
				if isList {
					value = ""
					//同一行可能多个数组同一个fname
					_val := strings.TrimSpace(cell.String())
					if isAlias {
						_val = getFileAliasValue(filename, _val)
					}
					ss := strings.Split(_val, listSplit)
					for i, v := range ss {
						if i != 0 {
							value += ","
						}
						value += "\"" + v + "\""
					}
				} else {
					var sbf bytes.Buffer
					sbf.WriteString("\"")
					sbf.WriteString(value)
					sbf.WriteString("\"")
					value = sbf.String()
				}

			} else if isMap {
				//map类型了，再者就是找不到

				kvstr := strings.TrimPrefix(writeTypeStr, "<")
				kvstr = strings.TrimSuffix(kvstr, ">")
				kvs := strings.Split(kvstr, ",")
				tk := kvs[0]
				tv := kvs[1]
				if !isBaseType(tk) && tk != "string" {
					Error("lua: Dictionary只支持key都是string或基本数据类型 id:%s, key:%s ", row.Cells[0].String(),  tname)
				}
				value = ""
				var curfname = cell.String()
				if curfname == "" {
					continue
				}
				var lastAnno string
				//map类型的解析和拼装
				buf.WriteString( fname + " = {")
				var keyValueStrs = strings.Split(cell.String(), ",")
				for i:=0; i<len(keyValueStrs); i++{
					_kvStr := strings.Split(keyValueStrs[i],":")
					if len(_kvStr) != 2 {
						Warn("json: map的key或者value为空，将被忽略，id:%s, 配置",cell.String())
						continue
					}
					_key := strings.TrimSpace(_kvStr[0])
					_val := strings.TrimSpace(_kvStr[1])

					if _key == "" || _val == ""{
						Warn("lua: map的key或者value为空，将被忽略，id:%s, key:%s  value:%s",row.Cells[0].String(), _key, _val)
						continue
					}
					isAlias := (getCmdValue(sheet, index, "alias") == "true")
					if isAlias {
						_key = getFileAliasValue(filename, _key)
						_val = getFileAliasValue(filename, _val)
					}
					if curfname != ""  {
						if _val == "" {
							_val = g.getEmptyVal(tv)
							continue
						}
						_val = strings.TrimSuffix(_val, ",")
						if lastAnno != "" {
							value += "   --" + lastAnno
						}
						value += "\n" + getTabs(level+2)
						if isBaseType(tk) {
							value += "[" + _key + "] = "
						} else if tk == "string" {
							value +=  _key + " = "
						}
						if isBaseType(tv) {
							value += _val
						} else if tv == "string" {
							value += "\"" + _val + "\""
						} else {
							var subFilename string
							var subSheetName string
							//被点分开说明是外部表
							ss := strings.Split(tv, ".")
							if len(ss) == 2 {
								subFilename = ss[0]
								subSheetName = ss[1]
							} else {
								subFilename = filename
								subSheetName = tv
							}
							subsheet, ok := getFileSheet(subFilename, subSheetName)
							if ok {
								st := getSheetType(subsheet)
								if st == "enum" {
									Error("lua: map的value不支持枚举类型 " + curfname)
									continue
								} else if st == "object" {
									Error("lua: map的value不支持此未知类型"+curfname)
								}
							}
						}
						value += ","

						lastAnno = getComment(sheet, i)
					}
				}
				value = strings.TrimRight(value, ",")
				if lastAnno != "" {
					value += "   --" + lastAnno
				}
				value += "\n" + getTabs(level+1) + "}"

			} else {//剩下是object和枚举
				if tname == "" {
					continue
				}
				subFilename := filename
				subSheetName := tname
				//被点分开说明是外部表
				ss := strings.Split(tname, ".")
				if len(ss) == 2 {
					subFilename = ss[0]
					subSheetName = ss[1]
				}
				subsheet, ok := getFileSheet(subFilename, subSheetName)
				ctype := ""
				if !ok {
					Error("lua: 找不到sheet：" + tname)
					continue
				} else {
					ctype = getSheetType(subsheet)
				}
				switch ctype {
				case "object":
					Error("lua: 不支持此未知类型"+fname)
				case "enum":
					buf.WriteString(fname + " = ")
					find := false
					for _, row := range subsheet.Rows {
						_, _value, alias, _, _ := getEnumValue(row)
						//命中此行
						if alias == value || value == _value {
							value = _value
							find = true
							break
						}
					}
					tname = ctype
					if !find {
						Error("lua: 不存在的枚举值 ： " + subsheet.Name + " : " + value)
					}
					if value == "" {
						value = subsheet.Rows[2].Cells[1].String()
						Warn("lua: 字段 " + fname + " 枚举值为空，默认为 ：" + subsheet.Name + "/" + value)
					}
				default:
					Error("lua: 错误！" + sheet.Name + "找不到Sheet： " + writeTypeStr)
				}
			}

			if isStrEmpty(value) {
				if isList {
					value = "{}"
				} else {
					value = g.getEmptyVal(tname)
				}
			} else {
				if isList {
					value = "{" + value + "}"
				}
			}
			buf.WriteString(value)
			//一个cell结束了
			if index < len(row.Cells)-1 {
				//如果后面还有没写出的cell，那么加“,”
				for i := index + 1; i < len(row.Cells); i++ {
					tstr := fieldCells[i].String()
					if tstr == "" || strings.HasPrefix(tstr, "!") {
						continue
					}
					writed, ok := writedCellMap[i]
					if !ok || !writed {
						buf.WriteString(",")
						break
					}
				}
			}

			an := getComment(sheet, index)
			if an != "" {
				buf.WriteString("    --")
				buf.WriteString(an)
			}
		}
		buf.WriteString("\n")
		buf.WriteString(getTabs(level) + "}")

	}
}

func (g *Genlua) getEmptyVal(t string) string {
	result := ""
	if t == "string" {
		result = "\"\""
	} else if isBaseType(t) {
		result = "0"
	} else if t == "object" {
		result = "nil"
	} else if t == "enum" {
		result = "0"
	}
	return result
}
