package generator

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/user"
	"path"
	"path/filepath"
	"strconv"
	"strings"
	"time"

	"github.com/tealeg/xlsx"
)

var (
	genlua = newGenlua()
)

func Lua() *Genlua {
	return genlua
}

type Genlua struct {
	genPath string
}

func newGenlua() *Genlua {
	g := &Genlua{}
	return g
}
func (g *Genlua) Gen(outPath string) {
	g.genPath = outPath + "/"
	for _, f := range Xlsxfiles {
		fn := filepath.Base(f)
		if !strings.HasPrefix(fn, "~$") && strings.HasSuffix(fn, ".xlsx") {
			g.genLocal(f)
		} else {
			Warn("lua: 排除非xlsx文件 ： " + f)
		}
	}
}
func (g *Genlua) createLuaFile(fname string, buf *bytes.Buffer) {

	outfile := g.genPath + fname + ".lua"
	Info("lua: 正在生成文件 ：" + outfile)
	Info("------------------------------------------------------------------------")
	_, ferr := os.Stat(outfile)
	if ferr == nil {
		os.Remove(outfile)
	}
	os.MkdirAll(filepath.Dir(outfile), 0755)
	ioutil.WriteFile(outfile, buf.Bytes(), 0666)
	luaf := path.Base(outfile)
	luaf = strings.TrimSuffix(luaf, ".lua")
}

func (g *Genlua) genLocal(file string) {

	//Info("------------------------------------------------------------------------")
	Info("lua: 正在读取Excel文件  ： " + file)

	filename := filepath.Base(file)
	filename = strings.TrimSuffix(filename, ".xlsx")

	exlf, ok := getFile(filename)
	if ok {
		genFile := false
		var buf bytes.Buffer
		u, err := user.Current()
		if err == nil {
			buf.WriteString("--Generated by egen, version=" + Version + ". By " + u.Username + ", " + time.Now().Format("2006-01-02 15:04:05") + "\n")
			buf.WriteString(PackageName + " = " + PackageName + " or {}")
			buf.WriteString("\n")
		} else {
			Warn("lua: 生成文件头信息出错")
		}
		for _, sheet := range exlf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && getSheetType(sheet) == "enum" {
				g.parseEnum(sheet, &buf)
				genFile = true
			}
		}
		for _, sheet := range exlf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && getSheetType(sheet) == "object" {
				buf.WriteString("\n")
				buf.WriteString(PackageName + "." + sheet.Name + " =")
				bs := g.processSheet(filename, sheet.Name)
				buf.WriteString(bs.String())
				genFile = true
			}
		}
		if genFile {
			g.createLuaFile(filename, &buf)
		} else {
			Warn("lua ： not gen")
		}
	}

}

func (g *Genlua) parseEnum(sheet *xlsx.Sheet, buf *bytes.Buffer) {
	if len(sheet.Rows) < 2 {
		Error("lua: 枚举表表头小于2行 : " + sheet.Name)
		return
	}
	nameList := make(map[string]bool, 0)
	valueList := make(map[string]bool, 0)

	buf.WriteString(PackageName + "." + sheet.Name + " = {\n")
	for index, row := range sheet.Rows {
		if index > 1 {
			buf.WriteString("\t")
			fieldName, value, alias, anno, _ := getEnumValue(row)
			if fieldName == "" || value == "" {
				Error("lua: 错误的枚举配置，字段或值配置为空：" + sheet.Name + "/" + fieldName)
				return
			}
			_, ok := valueList[value]
			if ok {
				Error("lua: 重复的枚举值：" + sheet.Name + ":" + value)
				return
			}
			_, ok = nameList[fieldName]
			if ok {
				Error("lua: 重复的枚举字段名：" + sheet.Name + ":" + fieldName)
				return
			}
			valueList[value] = true
			nameList[fieldName] = true
			buf.WriteString(fieldName)
			buf.WriteString(" = ")
			buf.WriteString(value)
			if index < len(sheet.Rows)-1 {
				buf.WriteString(",")
			}
			if alias != "" || anno != "" {
				buf.WriteString("  --")
				buf.WriteString(alias + "  " + anno)
			}
			buf.WriteString("\n")
		}
	}
	buf.WriteString("}\n")
}
func (g *Genlua) processSheet(filename string, sheetName string) *bytes.Buffer {
	Info("lua: 正在读取子表 sheet : " + sheetName + ".xlsx")
	buf := bytes.NewBufferString("")
	buf.WriteString("\n")
	sheet, ok := getFileSheet(filename, sheetName)
	level := 0
	if ok {
		buf.WriteString(getTabs(level) + "{\n")
		if len(sheet.Rows) < 4 {
			Fatal("lua: 表头小于4行" + sheet.Name)
			return buf
		}
		isList := true
		isRoot := true
		g.processSheetLoop(buf, filename, sheetName, make([]string, 0), level, isRoot, isList)
		buf.WriteString("\n" + getTabs(level) + "}")
	}

	return buf
}

func (g *Genlua) processSheetLoop(buf *bytes.Buffer, filename string, sheetName string, pIds []string, level int, pIsRoot bool, pIsList bool) {
	sheet, ok := getFileSheet(filename, sheetName)
	if !ok {
		return
	}
	fieldCells := sheet.Rows[2].Cells
	typeCells := sheet.Rows[3].Cells
	fnameid := fieldCells[0].String()
	if strings.TrimPrefix(fnameid, "!") != "id" {
		Error("lua: 错误！要求表格第一列字段必须为 id ,但为 ： " + fnameid)
		return
	}

	level++
	isFirstSheetWirte := true
	//id命中的行数，
	ownerRows := make([]*xlsx.Row, 0)
	for index, row := range sheet.Rows {
		if index >= 4 && len(row.Cells) > 0 {
			mainId := row.Cells[0].String()
			//idName := fieldCells[0].String()
			//如果没有填写id则忽略
			if mainId == "" {
				continue
			}
			if pIsRoot {
				ownerRows = append(ownerRows, row)
			} else {
				contain := func(id string) bool {
					for _, v := range pIds {
						if id == v {
							return true
						}
					}
					return false
				}
				//id刷选，只打印id匹配成功的
				if contain(mainId) {
					ownerRows = append(ownerRows, row)
				}
			}
		}
	}
	if !pIsList && len(ownerRows) > 1 {
		pidstr := func() string {
			result := ""
			for _, v := range pIds {
				result += v + ","
			}
			return result
		}
		Error("lua: 矛盾，为非数组类型，但找到超过1个实例对象:" + sheet.Name + "  ids:" + pidstr())
		return
	}

	for _, row := range ownerRows {
		if isFirstSheetWirte == false {
			buf.WriteString(",\n")
			buf.WriteString(getTabs(level))
		}
		if isFirstSheetWirte && pIsRoot {
			buf.WriteString(getTabs(level))
		}
		isFirstSheetWirte = false

		if pIsRoot {
			curid := row.Cells[0].String()
			tname := typeCells[0].String()
			if isBaseType(tname) {
				buf.WriteString("[" + curid + "]" + "=")
			} else if tname == "string" {
				buf.WriteString("[\"" + curid + "\"]" + "=")
			} else {
				Error("lua: 每行数据头的字段 id 数据类型只能为基本类型或string")
				continue
			}
		}
		buf.WriteString("{")

		//记录map和list写出的cell，后面不再写出
		writedCellMap := make(map[int]bool, 0)
		//排除属性名为空的字段
		for index, cell := range row.Cells {

			writed, ok := writedCellMap[index]
			if ok && writed {
				continue
			}

			//排除属性名为空的字段
			tname := strings.TrimSpace(typeCells[index].String())
			fname := strings.TrimSpace(fieldCells[index].String())
			value := strings.TrimSpace(cell.String())
			writeTypeStr := typeCells[index].String()
			if fname == "" {
				continue
			}
			if strings.HasPrefix(fname, "!") {
				continue
			}

			isAlias := (getCmdValue(sheet, index, "alias") == "true")
			listSplit := getCmdValue(sheet, index, "split")
			if listSplit == "" {
				listSplit = ","
			}

			buf.WriteString("\n")

			if isAlias {
				if isAlias {
					value = getFileAliasValue(filename, value)
				}
			}

			isMap := isMapField(tname)
			if isMap { //字典kv对
				_, err := strconv.Atoi(fname)
				if err == nil {
					fname = "[" + fname + "]"
				} else {
					fname = "['" + fname + "']"
				}
			}
			buf.WriteString(getTabs(level + 1))

			//对象是否数组类型
			isList := isListField(tname)
			if isList {
				tname = strings.TrimPrefix(tname, "<")
				tname = strings.TrimSuffix(tname, ">")
			}
			if isBaseType(tname) {
				buf.WriteString(fname + " = ")
				if isList {
					value = ""
					for i := index; i < len(row.Cells); i++ {
						_cell := row.Cells[i]
						_name := fieldCells[i].String()
						if fname == _name {
							writedCellMap[i] = true
							_valList := strings.Split(_cell.String(), listSplit)
							newv := ""
							for _, v := range _valList {
								if v == "" {
									continue
								}
								if isAlias {
									newv += getFileAliasValue(filename, v)
								} else {
									newv += v
								}
								newv += ","
							}
							newv = strings.TrimSuffix(newv, ",")
							if i != index {
								value += ", "
							}
							value += newv
						}
					}
				}
			} else if tname == "string" {
				buf.WriteString(fname + " = ")
				if isList {
					value = ""
					//同一行可能多个数组同一个fname
					for i := index; i < len(row.Cells); i++ {
						_cell := row.Cells[i]
						_name := fieldCells[i].String()
						_val := _cell.String()
						if isAlias {
							_val = getFileAliasValue(filename, _val)
						}
						//同一个fname，同个字段共用
						if fname == _name {
							writedCellMap[i] = true
							if i != index {
								value += ", "
							}
							ss := strings.Split(_val, listSplit)
							for i, v := range ss {
								if i != 0 {
									value += ","
								}
								value += "\"" + v + "\""
							}
						}
					}
				} else {
					var sbf bytes.Buffer
					sbf.WriteString("\"")
					sbf.WriteString(value)
					sbf.WriteString("\"")
					value = sbf.String()
				}

			} else if isMap {
				//map类型了，再者就是找不到

				kvstr := strings.TrimPrefix(writeTypeStr, "<")
				kvstr = strings.TrimSuffix(kvstr, ">")
				kvs := strings.Split(kvstr, ",")
				tk := kvs[0]
				tv := kvs[1]
				if !isBaseType(tk) && tk != "string" {
					Error("lua: Dictionary只支持key都是string或基本数据类型 id:%s, key:%s ", row.Cells[0].String(),  tname)
				}
				value = ""
				var curfname string
				var lastAnno string
				//map类型的解析和拼装
				//从新遍历出所有filedname 为当前map字段名的值对
				for i := index; i < len(row.Cells); i++ {
					_fname := fieldCells[i].String()
					if i == index {
						curfname = _fname
						buf.WriteString( curfname + " = {")
					}
					if _fname == "" || _fname != curfname{
						continue
					}
					if i+1 >= len(row.Cells) {
						Warn("lua: map找不到值定义，将被忽略，id:%s, key:%s",row.Cells[0].String(), row.Cells[i].String())
						continue
					}
					_key := strings.TrimSpace(row.Cells[i].String())
					_val := strings.TrimSpace(row.Cells[i+1].String())
					if _key == "" || _val == ""{
						Warn("lua: map的key或者value为空，将被忽略，id:%s, key:%s  value:%s",row.Cells[0].String(), _key, _val)
						continue
					}
					isAlias := (getCmdValue(sheet, i, "alias") == "true")
					if isAlias {
						_key = getFileAliasValue(filename, _key)
						_val = getFileAliasValue(filename, _val)
					}
					if curfname != "" && _fname == curfname {
						writedCellMap[i] = true
						writedCellMap[i+1] = true
						if _val == "" {
							_val = g.getEmptyVal(tv)
							continue
						}
						_val = strings.TrimSuffix(_val, ",")
						if lastAnno != "" {
							value += "   --" + lastAnno
						}
						value += "\n" + getTabs(level+2)
						if isBaseType(tk) {
							value += "[" + _key + "] = "
						} else if tk == "string" {
							value += "[\"" + _key + "\"] = "
						}
						if isBaseType(tv) {
							value += _val
						} else if tv == "string" {
							value += "\"" + _val + "\""
						} else {
							var subFilename string
							var subSheetName string
							//被点分开说明是外部表
							ss := strings.Split(tv, ".")
							if len(ss) == 2 {
								subFilename = ss[0]
								subSheetName = ss[1]
							} else {
								subFilename = filename
								subSheetName = tv
							}
							subsheet, ok := getFileSheet(subFilename, subSheetName)
							if ok {
								st := getSheetType(subsheet)
								if st == "enum" {
									Error("lua: map的value不支持枚举类型 " + curfname)
									continue
								} else if st == "object" {
									isRoot := false
									isList := true
									subBuf := bytes.NewBufferString("")
									//类定义的根据所填的id去找
									ids := strings.Split(_val, listSplit)
									if isAlias {
										for index, id := range ids {
											ids[index] = getFileAliasValue(filename, id)
										}
									}
									g.processSheetLoop(subBuf, subFilename, subSheetName, ids, level+1, isRoot, isList)
									value += subBuf.String()
								}
							}
						}
						value += ","

						lastAnno = getComment(sheet, i)
					}
				}
				value = strings.TrimRight(value, ",")
				if lastAnno != "" {
					value += "   --" + lastAnno
				}
				value += "\n" + getTabs(level+1) + "}"

			} else {//剩下是object和枚举
				if tname == "" {
					continue
				}
				subFilename := filename
				subSheetName := tname
				//被点分开说明是外部表
				ss := strings.Split(tname, ".")
				if len(ss) == 2 {
					subFilename = ss[0]
					subSheetName = ss[1]
				}
				subsheet, ok := getFileSheet(subFilename, subSheetName)
				ctype := ""
				if !ok {
					Error("lua: 找不到sheet：" + tname)
					continue
				} else {
					ctype = getSheetType(subsheet)
				}
				switch ctype {
				case "object":
					buf.WriteString(fname + " = ")
					isRoot := false
					subBuf := bytes.NewBufferString("")
					vals := row.Cells[index].String()
					//类定义的根据所填的id去找
					ids := strings.Split(vals, listSplit)
					if isAlias {
						for index, id := range ids {
							ids[index] = getFileAliasValue(filename, id)
						}
					}
					g.processSheetLoop(subBuf, subFilename, subSheetName, ids, level, isRoot, isList)
					value = subBuf.String()
					tname = ctype
				case "enum":
					buf.WriteString(fname + " = ")
					find := false
					for _, row := range subsheet.Rows {
						_, _value, alias, _, _ := getEnumValue(row)
						//命中此行
						if alias == value || value == _value {
							value = _value
							find = true
							break
						}
					}
					tname = ctype
					if !find {
						Error("lua: 不存在的枚举值 ： " + subsheet.Name + " : " + value)
					}
					if value == "" {
						value = subsheet.Rows[2].Cells[1].String()
						Warn("lua: 字段 " + fname + " 枚举值为空，默认为 ：" + subsheet.Name + "/" + value)
					}
				default:
					Error("lua: 错误！" + sheet.Name + "找不到Sheet： " + writeTypeStr)
				}
			}

			if isStrEmpty(value) {
				if isList {
					value = "{}"
				} else {
					value = g.getEmptyVal(tname)
				}
			} else {
				if isList {
					value = "{" + value + "}"
				}
			}
			buf.WriteString(value)
			//一个cell结束了
			if index < len(row.Cells)-1 {
				//如果后面还有没写出的cell，那么加“,”
				for i := index + 1; i < len(row.Cells); i++ {
					tstr := fieldCells[i].String()
					if tstr == "" || strings.HasPrefix(tstr, "!") {
						continue
					}
					writed, ok := writedCellMap[i]
					if !ok || !writed {
						buf.WriteString(",")
						break
					}
				}
			}

			an := getComment(sheet, index)
			if an != "" {
				buf.WriteString("    --")
				buf.WriteString(an)
			}
		}
		buf.WriteString("\n")
		buf.WriteString(getTabs(level) + "}")

	}
}

func (g *Genlua) getEmptyVal(t string) string {
	result := ""
	if t == "string" {
		result = "\"\""
	} else if isBaseType(t) {
		result = "0"
	} else if t == "object" {
		result = "nil"
	} else if t == "enum" {
		result = "0"
	}
	return result
}
