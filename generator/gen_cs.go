package generator

import (
	"bytes"
	"io/ioutil"
	"os"
	"os/user"
	"path/filepath"
	"strings"
	"time"

	"github.com/tealeg/xlsx"
)

var (
	gencs = newGencs()
)

func Cs() *Gencs {
	return gencs
}

type Gencs struct {
	genPath string //生成路径
}

func newGencs() *Gencs {
	g := &Gencs{}
	return g
}

func (g *Gencs) Gen(outPath string) {

	g.genPath = outPath + "/"
	for _, f := range Xlsxfiles {
		fn := filepath.Base(f)
		if !strings.HasPrefix(fn, "~$") && strings.HasSuffix(fn, ".xlsx") {
			g.genLocal(f)
		} else {
			Warn("cs: 排除非xlsx文件 ：" + f)
		}
	}
}

func (g *Gencs) genLocal(file string) {
	//Info("------------------------------------------------------------------------")
	Info("cs：正在读取Excel文件  ：" + file)

	filename := filepath.Base(file)
	filename = strings.TrimSuffix(filename, ".xlsx")

	var buf bytes.Buffer
	u, err := user.Current()
	if err == nil {
		buf.WriteString("//Generated by egen, version=" + Version + ". By " + u.Username + ", " + time.Now().Format("2006-01-02 15:04:05") + "\n")
	}
	buf.WriteString("using System;\n")
	buf.WriteString("using System.Collections;\n")
	buf.WriteString("using System.Collections.Generic;\n")
	buf.WriteString("using System.Text;\n")
	buf.WriteString("namespace " + PackageName + "{\n")

	xf, ok := getFile(filename)
	if ok {
		//生成枚举
		for _, sheet := range xf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && getSheetType(sheet) == "enum" {
				level := 1
				g.parseEnum(sheet, &buf, level)
			}
		}
		//生成类
		for _, sheet := range xf.Sheets {
			if !strings.HasPrefix(sheet.Name, "!") && sheet.Name != "@Alias" && getSheetType(sheet) == "object" {
				buf.WriteString(getTabs(1) + "public class ")
				buf.WriteString(sheet.Name)
				b := g.processBuildinSheet(filename, sheet.Name, 1)
				buf.WriteString(b.String())
				buf.WriteString("\n")
			}
		}
		buf.WriteString("}")
		outfile := g.genPath + filename + ".cs"
		Info("cs: 正在生成文件 ：" + outfile)
		Info("------------------------------------------------------------------------")
		_, ferr := os.Stat(outfile)
		if ferr == nil {
			os.Remove(outfile)
		}

		os.MkdirAll(filepath.Dir(outfile), 0755)
		ioutil.WriteFile(outfile, buf.Bytes(), 0666)
	}

}

func (g *Gencs) parseEnum(sheet *xlsx.Sheet, buf *bytes.Buffer, tabCount int) {
	if len(sheet.Rows) < 2 {
		Error("cs: 枚举表表头小于2行 : " + sheet.Name)
		return
	}
	nameList := make(map[string]bool, 0)
	valueList := make(map[string]bool, 0)
	buf.WriteString(getTabs(tabCount) + "public enum " + toUp(sheet.Name) + " {\n")
	for index, row := range sheet.Rows {
		if index > 1 {
			buf.WriteString("\t")
			name := row.Cells[0].String()
			value := row.Cells[1].String()
			alias := row.Cells[2].String()
			anno := row.Cells[3].String()
			if name == "" || value == "" {
				Error("cs: 错误的枚举配置，字段或值配置为空：" + sheet.Name + "/" + name)
				return
			}
			_, ok := valueList[value]
			if ok {
				Error("cs: 重复的枚举值：" + sheet.Name + ":" + value)
				return
			}
			_, ok = nameList[name]
			if ok {
				Error("cs: 重复的枚举字段名：" + sheet.Name + ":" + name)
				return
			}
			valueList[value] = true
			nameList[name] = true
			buf.WriteString(getTabs(tabCount) + toUp(name))
			buf.WriteString(" = ")
			buf.WriteString(value + ",")
			if alias != "" || anno != "" {
				buf.WriteString("    //")
				buf.WriteString(alias + "  " + anno)
			}
			buf.WriteString("\n")
		}
	}
	buf.WriteString(getTabs(tabCount) + "}\n")
}

func (g *Gencs) processBuildinSheet(filename string, sheetName string, level int) *bytes.Buffer {
	Info("cs: 正在读取子表 sheet : " + "/" + sheetName)

	buf := bytes.NewBufferString("")
	sheet, ok := getFileSheet(filename, sheetName)
	if !ok {
		return buf
	}
	if len(sheet.Rows) < 4 {
		Error("cs: 表格配置" + filename + "/" + sheetName + "少于4行")
		return buf
	}
	buf.WriteString("{\n")
	level++
	//level==2时为类定义的顶层类，此时嵌入枚举

	fieldNameRow := sheet.Rows[2]
	fieldTypeRow := sheet.Rows[3]

	writedMap := make(map[int]bool)
	isMapFront := false //前面是map的话下一个是它的值

	for index, nameCell := range fieldNameRow.Cells {
		if isMapFront {
			continue
		}
		isMapFront = false
		typeCell := fieldTypeRow.Cells[index]
		fname := strings.TrimSpace(nameCell.String())
		tname := strings.TrimSpace(typeCell.String())
		if tname == "" || fname == "" {
			continue
		}
		pureTname := strings.TrimPrefix(tname, "<")
		pureTname = strings.TrimSuffix(pureTname, ">")
		writeTypeStr := strings.TrimSpace(typeCell.String())
		if strings.HasPrefix(fname, "!") {
			continue
		}
		writed, ok := writedMap[index]
		if ok && writed {
			continue
		}
		writedMap[index] = true
		buf.WriteString(getTabs(level))

		var isList bool
		var isMap bool
	
		isList = isListField(tname)
		if isList {
			isMap = false
		} else {
			isMap = isMapField(tname)
			isMapFront = isMap
		}

		var subSheetExist bool
		if !isMap {
			if pureTname == "string" {
				writeTypeStr = pureTname
			} else if isBaseType(pureTname) {
				writeTypeStr = g.getCSBaseType(pureTname)
			} else {
				var subSheet *xlsx.Sheet
				ss := strings.Split(pureTname, ".")
				if len(ss) == 2 {
					subFilename := ss[0]
					subSheetName := ss[1]
					subSheet, subSheetExist = getFileSheet(subFilename, subSheetName)
				} else {
					subSheet, subSheetExist = getFileSheet(filename, pureTname)
				}
				if subSheetExist {
					//枚举和类定义
					writeTypeStr = subSheet.Name
				}
			}
		} else {
			//Map类型
			//检查配置是否正确
			newstr := strings.TrimPrefix(tname, "<")
			newstr = strings.TrimSuffix(newstr, ">")
			kvstr := strings.Split(newstr, ",")
			if len(kvstr) == 2 {
				tk := kvstr[0]
				tv := kvstr[1]
				if !isBaseType(tk) && tk != "string" {
					Error("cs: Dictionary只支持key是string或基本数据类型 : " + tname)
				}
				var subFilename string
				var subSheetName string
				if !isBaseType(tv) && tv != "string" {
					//被点分开说明是外部表
					ss := strings.Split(tv, ".")
					if len(ss) == 2 {
						subFilename = ss[0]
						subSheetName = ss[1]
					} else {
						subFilename = filename
						subSheetName = tv
					}
					Warn("getFileSheet(subFilename, subSheetName) "+subSheetName)
					subSheet, ok := getFileSheet(subFilename, subSheetName)
					if getSheetType(subSheet) == "enum" {
						Error("cs: map的value不支持枚举类型 " + tname)
						continue
					}
					if !ok {
						Error("go： 找不到表 " + subFilename + "/" + subSheetName)
						continue
					} else {
						writeTypeStr = "Dictionary<" + tk + "," + subSheetName + ">"
					}
				} else {
					writeTypeStr = "Dictionary<" + g.getCSBaseType(tk) + "," + g.getCSBaseType(tv) + ">"
				}
			} else {
				Error("cs: 错误的Dictionary配置：" + tname)
			}
		}
		if !subSheetExist && !isBaseType(pureTname) && pureTname != "string" && !isMap {
			Error("cs: 未知的类型定义： " + tname)
			continue
		}
		if isList || isMap {
			for i := index; i < len(fieldNameRow.Cells); i++ {
				_cell := fieldNameRow.Cells[i]
				if _cell.String() == fname {
					writedMap[i] = true
				}
			}
		}

		if isList {
			writeTypeStr = writeTypeStr + "[]"
		}
		//cs配置的强制修改的类型
		csType := getCmdValue(sheet, index, "csType")
		if csType != "" {
			writeTypeStr = csType
		}
		buf.WriteString("public " + writeTypeStr + " " + fname + ";")

		buf.WriteString(getTabs(1))
		an := getComment(sheet, index)
		if an != "" {
			buf.WriteString(" //")
			buf.WriteString(an)
		}
		buf.WriteString("\n")
	}

	buf.WriteString(getTabs(level - 1))
	buf.WriteString("}")
	return buf
}

func (g *Gencs) getCSBaseType(tname string) string {
	if tname == "int64" || tname == "int32" || tname == "int16" {
		tname = toUp(tname)
	} else if tname == "float32" {
		tname = "float"
	} else if tname == "float64" {
		tname = "long"
	} else if tname == "uint" {
	} else if strings.HasPrefix(tname, "uint") {
		tname = strings.Replace(tname, "uint", "UInt", 1)
	}
	return tname
}
